name: Deploy Branch Preview

# IMPORTANT: Security Model - Defense in Depth
#
# TWO-LAYER SECURITY:
#
# Layer 1 - CODE-LEVEL (Early Filter):
#   ‚Ä¢ check-authorization job checks if PR author is a collaborator
#   ‚Ä¢ Runs from main (pull_request_target) so can't be modified by PR
#   ‚Ä¢ Provides early feedback, skips deployment for unauthorized users
#   ‚Ä¢ Posts helpful comments for external contributors
#
# Layer 2 - PLATFORM-LEVEL (Ultimate Enforcement):
#   ‚Ä¢ GitHub Environment protection for FORK PRs only
#   ‚Ä¢ CANNOT be bypassed in code (GitHub platform enforces)
#   ‚Ä¢ Requires manual approval from lmcrean/admins for external contributors
#   ‚Ä¢ Configure: Settings ‚Üí Environments ‚Üí preview-deployments ‚Üí Required reviewers
#
# DEPLOYMENT PATHS:
#
# Path A - Same-Repo PRs (lmcrean's branches, including claude/* branches):
#   ‚úÖ NO environment protection ‚Üí auto-deploy immediately
#   ‚úÖ Uses branch-specific CI ‚Üí can test CI changes before merging
#   ‚úÖ Trusted users only (must have repo write access to push branches)
#
# Path B - Fork PRs (external contributors):
#   ‚ö†Ô∏è WITH environment protection ‚Üí requires manual approval
#   üîí Uses main's CI only ‚Üí prevents malicious workflow injection
#   üõ°Ô∏è Platform-enforced ‚Üí can't modify workflow to bypass
#   üö´ BAD ACTORS CANNOT: Inject malicious CI code and auto-deploy
#      Because: 1) They use main's CI (not their modified version)
#               2) They require manual approval (environment protection)
#               3) Detection logic runs from main (can't be tampered)
#
# RESULT:
# ‚úÖ lmcrean (same-repo): Auto-deploy + branch-specific CI
# ‚úÖ External (forks): Require approval + secure main CI
# ‚úÖ Defense in depth: Code-level + Platform-level security

on:
  pull_request_target:
    types: [opened, synchronize, reopened, labeled]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  deployments: write
  checks: write
  id-token: write

jobs:
  check-authorization:
    runs-on: ubuntu-latest
    # Skip this job if triggered by a label event that's not the deploy-preview label
    if: github.event_name != 'labeled' || github.event.label.name == 'deploy-preview'
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      pr_number: ${{ steps.check.outputs.pr_number }}
    steps:
      - name: Check if deployment is authorized
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            // Handle both pull_request_target and workflow_dispatch events
            let prNumber, prAuthor;

            if (context.eventName === 'workflow_dispatch') {
              // For manual triggers, get PR info from the branch
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${context.ref.replace('refs/heads/', '')}`,
                state: 'open'
              });

              if (prs.length === 0) {
                core.setOutput('authorized', 'false');
                core.notice('No open PR found for this branch');
                return;
              }

              prNumber = prs[0].number;
              prAuthor = prs[0].user.login;
            } else {
              // For pull_request_target events
              prNumber = context.payload.pull_request.number;
              prAuthor = context.payload.pull_request.user.login;
            }

            // Set PR number as output for use by other jobs
            core.setOutput('pr_number', prNumber.toString());

            // Check if author is a collaborator
            let isCollaborator = false;
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: prAuthor
              });
              // Collaborators have 'admin', 'write', or 'read' permission
              isCollaborator = ['admin', 'write', 'read'].includes(permission.permission);
              console.log(`User ${prAuthor} permission level: ${permission.permission}`);
            } catch (error) {
              console.log(`User ${prAuthor} is not a collaborator`);
            }

            // If user is a collaborator, authorize immediately
            if (isCollaborator) {
              console.log(`Authorized: ${prAuthor} is a repository collaborator`);
              core.setOutput('authorized', 'true');
              return;
            }

            // For external contributors, check for the deploy-preview label
            console.log(`External contributor detected: ${prAuthor}`);
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const hasDeployLabel = labels.some(label => label.name === 'deploy-preview');

            if (hasDeployLabel) {
              console.log(`Authorized: PR #${prNumber} has 'deploy-preview' label`);
              core.setOutput('authorized', 'true');
            } else {
              console.log(`Not authorized: External contributor without 'deploy-preview' label`);
              console.log(`A maintainer must add the 'deploy-preview' label to trigger deployment`);
              core.setOutput('authorized', 'false');

              // Post a comment explaining the situation
              try {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber
                });

                const botComment = comments.find(comment =>
                  comment.user.type === 'Bot' &&
                  comment.body.includes('DEPLOY_AUTHORIZATION_NEEDED')
                );

                if (!botComment) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: 'Deployment Authorization Required\n\nThank you for your contribution! As an external contributor, your PR requires manual approval before deployment previews are created.\n\nFor maintainers: Add the deploy-preview label to this PR to trigger the deployment workflow.\n\nDEPLOY_AUTHORIZATION_NEEDED'
                  });
                }
              } catch (error) {
                console.log('Failed to post comment:', error.message);
              }

              // Don't fail the job - just set authorized to false and let deploy job skip
              core.notice('Deployment paused - waiting for deploy-preview label');
            }

  # Deploy for SAME-REPO PRs (lmcrean's branches, including claude/* branches)
  # ‚úÖ NO environment protection ‚Üí auto-deploy immediately
  # ‚úÖ Uses branch-specific CI ‚Üí can test CI changes before merging
  # ‚úÖ Only runs for same-repo ‚Üí fork PRs can't use this path
  deploy-trusted:
    needs: check-authorization
    # Only for same-repo PRs (not forks) where author is authorized
    if: |
      needs.check-authorization.outputs.authorized == 'true' &&
      github.event.pull_request.head.repo.full_name == github.repository
    uses: ${{ format('lmcrean/ed-tech-app/.github/workflows/reusable-deploy.yml@{0}', github.head_ref || github.ref_name) }}
    secrets: inherit
    with:
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}

  # Deploy for FORK PRs (external contributors)
  # ‚ö†Ô∏è WITH environment protection ‚Üí REQUIRES approval from lmcrean/admins
  # üîí Uses main's CI only ‚Üí prevents malicious workflow injection
  # üõ°Ô∏è Platform-enforced security ‚Üí can't be bypassed in code
  deploy-external:
    needs: check-authorization
    # Only for fork PRs where author is authorized (has deploy-preview label)
    if: |
      needs.check-authorization.outputs.authorized == 'true' &&
      github.event.pull_request.head.repo.full_name != github.repository
    # PLATFORM-LEVEL SECURITY: Cannot be bypassed
    # Configure: Settings ‚Üí Environments ‚Üí preview-deployments ‚Üí Required reviewers
    environment:
      name: 'preview-deployments'
    uses: ./.github/workflows/reusable-deploy.yml
    secrets: inherit
    with:
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}

  test:
    needs: [check-authorization, deploy-trusted, deploy-external]
    # Run if either deploy job succeeded
    if: always() && (needs.deploy-trusted.result == 'success' || needs.deploy-external.result == 'success')
    # Use branch-specific workflow for same-repo, main's workflow for forks
    uses: ${{ github.event.pull_request.head.repo.full_name == github.repository && format('lmcrean/ed-tech-app/.github/workflows/reusable-test.yml@{0}', github.head_ref) || './.github/workflows/reusable-test.yml' }}
    secrets: inherit
    with:
      api_url: ${{ needs.deploy-trusted.result == 'success' && needs.deploy-trusted.outputs.api_url || needs.deploy-external.outputs.api_url }}
      web_url: ${{ needs.deploy-trusted.result == 'success' && needs.deploy-trusted.outputs.web_url || needs.deploy-external.outputs.web_url }}
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}
