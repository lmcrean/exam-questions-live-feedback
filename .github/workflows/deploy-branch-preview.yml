name: Deploy Branch Preview

# IMPORTANT: Security Model - Defense in Depth
#
# TWO-LAYER SECURITY:
#
# Layer 1 - CODE-LEVEL (Early Filter):
#   ‚Ä¢ check-authorization job checks if PR author is a collaborator
#   ‚Ä¢ Runs from main (pull_request_target) so can't be modified by PR
#   ‚Ä¢ Provides early feedback, skips deployment for unauthorized users
#   ‚Ä¢ Posts helpful comments for external contributors
#
# Layer 2 - PLATFORM-LEVEL (Ultimate Enforcement):
#   ‚Ä¢ GitHub Environment protection for FORK PRs only
#   ‚Ä¢ CANNOT be bypassed in code (GitHub platform enforces)
#   ‚Ä¢ Requires manual approval from lmcrean/admins for external contributors
#   ‚Ä¢ Configure: Settings ‚Üí Environments ‚Üí preview-deployments ‚Üí Required reviewers
#
# DEPLOYMENT PATHS:
#
# Path A - Same-Repo PRs (lmcrean's branches, including claude/* branches):
#   ‚úÖ NO environment protection ‚Üí auto-deploy immediately
#   ‚úÖ Uses branch-specific CI ‚Üí can test CI changes before merging
#   ‚úÖ Trusted users only (must have repo write access to push branches)
#
# Path B - Fork PRs (external contributors):
#   ‚ö†Ô∏è WITH environment protection ‚Üí requires manual approval
#   ‚úÖ Uses branch-specific CI ‚Üí contributors can test CI changes too!
#   üõ°Ô∏è Platform-enforced ‚Üí approval required BEFORE CI runs
#   üîç Admin reviews PR (including CI changes) BEFORE approving
#
# WHY FORK PRS CAN SAFELY USE BRANCH-SPECIFIC CI:
#   ‚Ä¢ Environment approval happens BEFORE deployment/CI runs
#   ‚Ä¢ Admin reviews the PR (including any CI changes) before approving
#   ‚Ä¢ Even if malicious code in CI, it won't run without approval
#   ‚Ä¢ Platform enforcement can't be bypassed in code
#   ‚Ä¢ Provides flexibility for contributors to test CI improvements
#
# RESULT:
# ‚úÖ lmcrean (same-repo): Auto-deploy + branch-specific CI
# ‚úÖ External (forks): Require approval + branch-specific CI
# ‚úÖ Defense in depth: Code-level + Platform-level security
# ‚úÖ Maximum flexibility: ALL contributors can test CI changes in branches

on:
  # For SAME-REPO PRs: Run workflow from PR branch (can test CI changes)
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  # For FORK PRs: Run workflow from main branch (security)
  pull_request_target:
    types: [opened, synchronize, reopened, labeled]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  deployments: write
  checks: write
  id-token: write

jobs:
  check-authorization:
    runs-on: ubuntu-latest
    # Skip label events that aren't deploy-preview
    # For pull_request_target: only run for fork PRs (same-repo handled by pull_request trigger)
    # For workflow_dispatch: always run (manual trigger)
    if: |
      (github.event_name != 'labeled' || github.event.label.name == 'deploy-preview') &&
      (github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request' ||
       (github.event_name == 'pull_request_target' && github.event.pull_request.head.repo.full_name != github.repository))
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      pr_number: ${{ steps.check.outputs.pr_number }}
      is_fork: ${{ steps.check.outputs.is_fork }}
    steps:
      - name: Check if deployment is authorized
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            // Handle both pull_request_target and workflow_dispatch events
            let prNumber, prAuthor;

            if (context.eventName === 'workflow_dispatch') {
              // For manual triggers, get PR info from the branch
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${context.ref.replace('refs/heads/', '')}`,
                state: 'open'
              });

              if (prs.length === 0) {
                core.setOutput('authorized', 'false');
                core.notice('No open PR found for this branch');
                return;
              }

              prNumber = prs[0].number;
              prAuthor = prs[0].user.login;
            } else {
              // For pull_request_target events
              prNumber = context.payload.pull_request.number;
              prAuthor = context.payload.pull_request.user.login;
            }

            // Set PR number as output for use by other jobs
            core.setOutput('pr_number', prNumber.toString());

            // Determine if this is a fork PR
            const isFork = context.payload.pull_request ?
              context.payload.pull_request.head.repo.full_name !== context.payload.pull_request.base.repo.full_name :
              false;
            core.setOutput('is_fork', isFork.toString());
            console.log(`Is fork PR: ${isFork}`);

            // Check if author is a collaborator
            let isCollaborator = false;
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: prAuthor
              });
              // Collaborators have 'admin', 'write', or 'read' permission
              isCollaborator = ['admin', 'write', 'read'].includes(permission.permission);
              console.log(`User ${prAuthor} permission level: ${permission.permission}`);
            } catch (error) {
              console.log(`User ${prAuthor} is not a collaborator`);
            }

            // If user is a collaborator, authorize immediately
            if (isCollaborator) {
              console.log(`Authorized: ${prAuthor} is a repository collaborator`);
              core.setOutput('authorized', 'true');
              return;
            }

            // For external contributors, check for the deploy-preview label
            console.log(`External contributor detected: ${prAuthor}`);
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const hasDeployLabel = labels.some(label => label.name === 'deploy-preview');

            if (hasDeployLabel) {
              console.log(`Authorized: PR #${prNumber} has 'deploy-preview' label`);
              core.setOutput('authorized', 'true');
            } else {
              console.log(`Not authorized: External contributor without 'deploy-preview' label`);
              console.log(`A maintainer must add the 'deploy-preview' label to trigger deployment`);
              core.setOutput('authorized', 'false');

              // Post a comment explaining the situation
              try {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber
                });

                const botComment = comments.find(comment =>
                  comment.user.type === 'Bot' &&
                  comment.body.includes('DEPLOY_AUTHORIZATION_NEEDED')
                );

                if (!botComment) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: 'Deployment Authorization Required\n\nThank you for your contribution! As an external contributor, your PR requires manual approval before deployment previews are created.\n\nFor maintainers: Add the deploy-preview label to this PR to trigger the deployment workflow.\n\nDEPLOY_AUTHORIZATION_NEEDED'
                  });
                }
              } catch (error) {
                console.log('Failed to post comment:', error.message);
              }

              // Don't fail the job - just set authorized to false and let deploy job skip
              core.notice('Deployment paused - waiting for deploy-preview label');
            }

  # Deploy for SAME-REPO PRs (lmcrean's branches, including claude/* branches)
  # ‚úÖ NO environment protection ‚Üí auto-deploy immediately
  # ‚úÖ Uses branch-specific CI from PR ‚Üí can test CI changes before merging
  # ‚úÖ Triggered by pull_request ‚Üí runs workflow FROM the PR branch
  # ‚úÖ Only runs for same-repo ‚Üí fork PRs can't use this path
  deploy-trusted:
    needs: check-authorization
    # Only for same-repo PRs via pull_request trigger (or workflow_dispatch)
    if: |
      (github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch') &&
      needs.check-authorization.outputs.authorized == 'true'
    uses: ./.github/workflows/reusable-deploy.yml
    secrets: inherit
    with:
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}

  # Deploy for FORK PRs (external contributors)
  # ‚ö†Ô∏è WITH environment protection ‚Üí REQUIRES approval from lmcrean/admins
  # üîí Uses main branch CI for security (workflow runs from main)
  # üõ°Ô∏è Platform-enforced security ‚Üí CI only runs AFTER manual approval
  # üîç Admin reviews PR (including CI changes) BEFORE approving deployment
  # ‚úÖ Triggered by pull_request_target ‚Üí runs workflow FROM main (secure)
  deploy-external:
    needs: check-authorization
    # Only for fork PRs via pull_request_target where author is authorized
    if: |
      github.event_name == 'pull_request_target' &&
      needs.check-authorization.outputs.authorized == 'true' &&
      needs.check-authorization.outputs.is_fork == 'true'
    # PLATFORM-LEVEL SECURITY: Cannot be bypassed
    # Admin must approve BEFORE deployment runs (including any CI changes)
    # Configure: Settings ‚Üí Environments ‚Üí preview-deployments ‚Üí Required reviewers
    environment:
      name: 'preview-deployments'
    uses: ./.github/workflows/reusable-deploy.yml
    secrets: inherit
    with:
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}

  test:
    needs: [check-authorization, deploy-trusted, deploy-external]
    # Run if either deploy job succeeded
    if: always() && (needs.deploy-trusted.result == 'success' || needs.deploy-external.result == 'success')
    # Uses workflow from current branch (PR branch for same-repo, main for forks)
    uses: ./.github/workflows/reusable-test.yml
    secrets: inherit
    with:
      api_url: ${{ needs.deploy-trusted.result == 'success' && needs.deploy-trusted.outputs.api_url || needs.deploy-external.outputs.api_url }}
      web_url: ${{ needs.deploy-trusted.result == 'success' && needs.deploy-trusted.outputs.web_url || needs.deploy-external.outputs.web_url }}
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}
