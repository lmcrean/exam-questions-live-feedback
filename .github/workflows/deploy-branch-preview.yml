name: Deploy Branch Preview

# IMPORTANT: Branch-Specific CI Workflow Logic & Security Model
#
# SECURITY MODEL (Platform-Level):
# - Uses GitHub Environment "preview-deployments" with required reviewers
# - CANNOT be bypassed in code (platform-enforced)
# - Repository admins (lmcrean) can bypass and auto-deploy
# - External fork contributors MUST wait for manual approval
#
# CI WORKFLOW LOGIC (Conditional):
# - Same-repo PRs: Use branch-specific workflows (@branch-ref)
#   → Allows lmcrean to test CI changes in branches
#   → Tests added/removed/modified in branch are reflected
# - Fork PRs: Use main's workflows (./workflows)
#   → Prevents malicious workflow injection
#   → External contributors can't modify CI to steal secrets
#
# Detection: github.event.pull_request.head.repo.full_name == github.repository
#
# Result:
# ✅ lmcrean: Auto-deploy (admin bypass) + branch-specific CI
# ✅ External forks: Require approval + secure main CI
# ✅ Platform enforced (can't be bypassed by modifying code)

on:
  pull_request_target:
    types: [opened, synchronize, reopened, labeled]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  deployments: write
  checks: write
  id-token: write

jobs:
  check-authorization:
    runs-on: ubuntu-latest
    # Skip this job if triggered by a label event that's not the deploy-preview label
    if: github.event_name != 'labeled' || github.event.label.name == 'deploy-preview'
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
      pr_number: ${{ steps.check.outputs.pr_number }}
    steps:
      - name: Check if deployment is authorized
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            // Handle both pull_request_target and workflow_dispatch events
            let prNumber, prAuthor;

            if (context.eventName === 'workflow_dispatch') {
              // For manual triggers, get PR info from the branch
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${context.ref.replace('refs/heads/', '')}`,
                state: 'open'
              });

              if (prs.length === 0) {
                core.setOutput('authorized', 'false');
                core.notice('No open PR found for this branch');
                return;
              }

              prNumber = prs[0].number;
              prAuthor = prs[0].user.login;
            } else {
              // For pull_request_target events
              prNumber = context.payload.pull_request.number;
              prAuthor = context.payload.pull_request.user.login;
            }

            // Set PR number as output for use by other jobs
            core.setOutput('pr_number', prNumber.toString());

            // Check if author is a collaborator
            let isCollaborator = false;
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: prAuthor
              });
              // Collaborators have 'admin', 'write', or 'read' permission
              isCollaborator = ['admin', 'write', 'read'].includes(permission.permission);
              console.log(`User ${prAuthor} permission level: ${permission.permission}`);
            } catch (error) {
              console.log(`User ${prAuthor} is not a collaborator`);
            }

            // If user is a collaborator, authorize immediately
            if (isCollaborator) {
              console.log(`Authorized: ${prAuthor} is a repository collaborator`);
              core.setOutput('authorized', 'true');
              return;
            }

            // For external contributors, check for the deploy-preview label
            console.log(`External contributor detected: ${prAuthor}`);
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const hasDeployLabel = labels.some(label => label.name === 'deploy-preview');

            if (hasDeployLabel) {
              console.log(`Authorized: PR #${prNumber} has 'deploy-preview' label`);
              core.setOutput('authorized', 'true');
            } else {
              console.log(`Not authorized: External contributor without 'deploy-preview' label`);
              console.log(`A maintainer must add the 'deploy-preview' label to trigger deployment`);
              core.setOutput('authorized', 'false');

              // Post a comment explaining the situation
              try {
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber
                });

                const botComment = comments.find(comment =>
                  comment.user.type === 'Bot' &&
                  comment.body.includes('DEPLOY_AUTHORIZATION_NEEDED')
                );

                if (!botComment) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: 'Deployment Authorization Required\n\nThank you for your contribution! As an external contributor, your PR requires manual approval before deployment previews are created.\n\nFor maintainers: Add the deploy-preview label to this PR to trigger the deployment workflow.\n\nDEPLOY_AUTHORIZATION_NEEDED'
                  });
                }
              } catch (error) {
                console.log('Failed to post comment:', error.message);
              }

              // Don't fail the job - just set authorized to false and let deploy job skip
              core.notice('Deployment paused - waiting for deploy-preview label');
            }

  deploy:
    needs: check-authorization
    if: needs.check-authorization.outputs.authorized == 'true'
    # Use branch-specific workflow for same-repo PRs, main's workflow for forks
    # Same-repo: lmcrean can test CI changes in branches
    # Fork PRs: use main's CI (security - prevents malicious workflow injection)
    uses: ${{ github.event.pull_request.head.repo.full_name == github.repository && format('lmcrean/ed-tech-app/.github/workflows/reusable-deploy.yml@{0}', github.head_ref) || './.github/workflows/reusable-deploy.yml' }}
    secrets: inherit
    with:
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}
      # GitHub Environment provides PLATFORM-LEVEL security (cannot be bypassed in code)
      # - Admins (lmcrean) can bypass and auto-deploy
      # - External contributors MUST wait for approval
      environment: 'preview-deployments'

  test:
    needs: [check-authorization, deploy]
    # Use branch-specific workflow for same-repo PRs, main's workflow for forks
    # Same-repo: lmcrean can test CI changes in branches
    # Fork PRs: use main's CI (security - prevents malicious workflow injection)
    uses: ${{ github.event.pull_request.head.repo.full_name == github.repository && format('lmcrean/ed-tech-app/.github/workflows/reusable-test.yml@{0}', github.head_ref) || './.github/workflows/reusable-test.yml' }}
    secrets: inherit
    with:
      api_url: ${{ needs.deploy.outputs.api_url }}
      web_url: ${{ needs.deploy.outputs.web_url }}
      deployment_type: 'branch'
      branch_name: ${{ github.head_ref || github.ref_name }}
      pr_number: ${{ needs.check-authorization.outputs.pr_number }}
